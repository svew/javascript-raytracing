<!--  Demo of lighting using more detailed material and light 
properties.  Same as Lighting2c otherwise.  Only changes are in
the fragment shader, which now gets material and light properties
as 3x3 matrices.  See Lighting3.js.
-->
<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Light/material properties</title>
</head>

<body> 
	<canvas id="theCanvas" width="600" height="400">
    Please use a browser that supports "canvas"
    </canvas>

<p>
Keyboard controls:
</p><ul style="list-style:none;">
<li>w - Move forward
</li><li>s - Move backward
</li><li>a - Move left
</li><li>d - Move right
</li><li>e - Move up
</li><li>q - Move down
</li><li>Up arrow - Look up
</li><li>Down arrow - Look down
</li><li>Left arrow - Turn left
</li><li>Right arrow - Turn right
</li></ul>

<!-- VERTEX SHADING

-->
<script id="vertexRaytracingShader" type="x-shader/x-vertex">

</script>

<!-- FRAGMENT SHADING

	Where probably the bulk of the work will happen. I figure each fragment
	represents a pixel, so we'll use that to send the rays out of. The
	FragCoord variable should contain the coordinate of the center of the
	pixel, so for each pixel we'll send out one or more rays to the world.
	Pseudocode:
	
	num_B: The number of times that the ray is allowed to bounce
	L[]: Array of lights
	F[]: Array of faces, including color/material/reflection/transparency data

	For each fragment/pixel:

		D: Direction of the ray
		P: The starting position of the ray
		NF: The closest face that intersects with the ray, starts as null
		C: The total color being collected by the ray

		For i = 0..num_B:
			
			For F in F[]:
				If every vertex of F is behind the halfplane created by D and P, ignore it
				Calculate if there's any point I in which the ray and F intersect
				If I exists:
					Set NF to either F or NF according to which I is closer
				For L in L[]:
					If F obstructs the line from P to L:
						Set L to 'obstructed'

			If i != 0: //If the starting position is on the eyeball, don't add the diffuse/specular properties of the lights
				Add the ambient light properties of the world to C
				For L in L[]:
					If L is not 'obstructed'
						Add the diffuse/specular properties of L to C

			If no NF was found (The ray didn't collide with a face):
				Either sample from skybox, or set that ray's contribution to 0
				Break out of the loop

			Else:
				D = The direction of the reflected ray when it bounces off the face NF
				P = I
				NF = null
				Reduce the subsiquent contributions of C of other faces the ray reaches by some factor

-->
<script id="fragmentRaytracingShader" type="x-shader/x-fragment">

</script>

<script id="vertexLightingShader" type="x-shader/x-vertex">
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform mat3 normalMatrix;
uniform vec4 lightPosition;

attribute vec4 a_Position;
attribute vec3 a_Normal;

varying vec3 fL;
varying vec3 fN;
varying vec3 fV;
void main() 
{
  // convert position to eye coords
  vec4 positionEye = view * model * a_Position;

  // convert light position to eye coords
  vec4 lightEye = view * lightPosition;

  // vector to light
  fL = (lightEye - positionEye).xyz;

  // transform normal vector into eye coords
  fN = normalMatrix * a_Normal;

  // vector from vertex position toward view point
  fV = normalize(-(positionEye).xyz);

  gl_Position = projection * view * model * a_Position;
}</script>

<script id="fragmentLightingShader" type="x-shader/x-fragment">
precision mediump float;

uniform mat3 materialProperties;
uniform mat3 lightProperties;
uniform float shininess;

varying vec3 fL;
varying vec3 fN;
varying vec3 fV;
void main() 
{
  // normalize after interpolating
  vec3 N = normalize(fN);
  vec3 L = normalize(fL);
  vec3 V = normalize(fV);

  // reflected vector
  vec3 R = reflect(-L, N);

  // multiply each lighting constant with the corresponding material constant,
  // then grab the three columns to get the ambient, diffuse, and specular components
  mat3 products = matrixCompMult(lightProperties, materialProperties);
  vec4 ambientColor = vec4(products[0], 1.0);
  vec4 diffuseColor = vec4(products[1], 1.0);
  vec4 specularColor = vec4(products[2], 1.0);

  // Lambert's law, clamp negative values to zero
  float diffuseFactor = max(0.0, dot(L, N));

  // specular factor from Phong reflection model
  float specularFactor = pow(max(0.0, dot(V, R)), shininess);

  // add the components together
  gl_FragColor = specularColor * specularFactor + diffuseColor * diffuseFactor + ambientColor;
  gl_FragColor.a = 1.0;
}
</script>

<script id="vertexColorShader" type="x-shader/x-vertex">
uniform mat4 transform;
attribute vec4 a_Position;
attribute vec4 a_Color;
varying vec4 color;
void main() 
{
  color = a_Color;
  gl_Position = transform * a_Position;
}
</script>

<script id="fragmentColorShader" type="x-shader/x-fragment">
precision mediump float;
varying vec4 color;
void main() 
{
  gl_FragColor = color;
}
</script>



		<script src="index_files/webgl-utils.js"></script>
		<script src="index_files/webgl-debug.js"></script>
		<script src="index_files/cuon-utils.js"></script>
		<script src="index_files/cuon-matrix.js"></script>
		
		<!-- Use three.js if you have it locally, for easier debugging -->
		<!--script src="../threejs/three.js"></script>--
		
		<!--  otherwise, load the minified version from the www -->
		<script src="index_files/three.js"></script>

		<script src="index_files/keyhandler.js"></script>
		<script src="index_files/Lighting3.js"></script>
		<script>window.onload = main</script>

</body></html>